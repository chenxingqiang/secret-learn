# Author: Chen Xingqiang
# SPDX-License-Identifier: BSD-3-Clause

"""
Federated Learning adapter for LedoitWolf

LedoitWolf is an UNSUPERVISED covariance estimation algorithm.
Data aggregated to SPU with full MPC protection.
SPU-based secure aggregation.

Mode: Federated Learning (FL)
Generated by: StandaloneAlgorithmMigrator
"""

import logging
from typing import Dict, Union, Optional

import numpy as np

try:
    from xlearn.covariance import LedoitWolf
    USING_XLEARN = True
except ImportError:
    from sklearn.covariance import LedoitWolf
    USING_XLEARN = False

try:
    from secretflow.data.ndarray.ndarray import FedNdarray
    from secretflow.data.vertical.dataframe import VDataFrame
    from secretflow.device import PYU, SPU
    from secretflow.device.device.pyu import PYUObject
    from secretflow.security.aggregation import SecureAggregator
    SECRETFLOW_AVAILABLE = True
except ImportError:
    SECRETFLOW_AVAILABLE = False


class FLLedoitWolf:
    """
    Federated Learning LedoitWolf
    
    LedoitWolf is an unsupervised covariance estimation algorithm.
    
    In SS mode:
    - All data aggregated to SPU (Secure Processing Unit) for encrypted computation
    - Results are securely aggregated via SPU encryption
    - No labels (y) are needed - this is unsupervised learning
    
    Parameters
    ----------
    spu : SPU
        Dictionary mapping party names to PYU devices
    spu : SPU, optional
        Homomorphic encryption unit for secure aggregation
    aggregation_method : str, default='mean'
        How to aggregate results: 'mean', 'weighted_mean'
    **kwargs
        Parameters passed to LedoitWolf
    
    Examples
    --------
    >>> import secretflow as sf
    >>> alice = sf.PYU('alice')
    >>> bob = sf.PYU('bob')
    >>> spu = sf.SPU(sf.SPUConfig(...), ...)
    >>> 
    >>> # Unsupervised covariance estimation - no labels needed
    >>> model = FLLedoitWolf(
    >>>     devices={'alice': alice, 'bob': bob},
    >>>     spu=spu
    >>> )
    >>> 
    >>> # Fit on federated data (no y labels)
    >>> model.fit(fed_X)
    >>> 
    >>> # Transform data
    >>> X_transformed = model.transform(fed_X_test)
    """
    
    def __init__(
        self,
        spu : SPU,
        spu: Optional[SPU] = None,
        aggregation_method: str = 'mean',
        **kwargs
    ):
        if not SECRETFLOW_AVAILABLE:
            raise RuntimeError("SecretFlow not installed. Install: pip install secretflow")
        
        self.devices = devices
        self.spu = spu
        self.aggregation_method = aggregation_method
        self.kwargs = kwargs
        
        # Create local models on each PYU
        self.local_models = {}
        for party_name, device in devices.items():
            self.local_models[party_name] = device(self._create_local_model)(**kwargs)
        
        # Track if models are fitted
        self._is_fitted = False
        
        if USING_XLEARN:
            logging.info("[FL] FLLedoitWolf initialized with JAX acceleration")
        else:
            logging.info("[FL] FLLedoitWolf initialized with sklearn")
        
        logging.info(f"[FL] Parties: {list(devices.keys())}")
        logging.info(f"[FL] Aggregation: {aggregation_method}")
        logging.info(f"[FL] SPU enabled: {spu is not None}")
    
    @staticmethod
    def _create_local_model(**kwargs):
        """Create local LedoitWolf instance"""
        return LedoitWolf(**kwargs)
    
    def fit(self, x: Union[FedNdarray, VDataFrame]):
        """
        Fit the federated LedoitWolf model
        
        This is UNSUPERVISED learning - no labels (y) are needed.
        All data aggregated to SPU (Secure Processing Unit) for encrypted computation.
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Federated features (vertically or horizontally partitioned)
            Data stays local on each PYU
        
        Returns
        -------
        self : FLLedoitWolf
            Fitted model
        """
        if isinstance(x, VDataFrame):
            x = x.values
        
        logging.info("[FL] Starting federated LedoitWolf covariance estimation (unsupervised)")
        logging.info(f"[FL] Partitions: {len(x.partitions)}")
        
        # All data aggregated to SPU (Secure Processing Unit) for encrypted computation
        for party_name, device in self.devices.items():
            if device in x.partitions:
                X_local = x.partitions[device]
                model = self.local_models[party_name]
                
                # Train local model
                def _local_fit(model, X):
                    model.fit(X)
                    # Return model statistics for verification
                    n_samples = X.shape[0]
                    n_features = X.shape[1] if len(X.shape) > 1 else 1
                    n_components = getattr(model, 'n_components', None) or getattr(model, 'n_components_', None)
                    return n_samples, n_features, n_components
                
                result = device(_local_fit)(model, X_local)
                logging.info(f"[FL] Party '{party_name}' completed local covariance estimation")
        
        self._is_fitted = True
        logging.info("[FL] Federated LedoitWolf covariance estimation completed")
        return self
    
    def transform(self, x: Union[FedNdarray, VDataFrame]):
        """
        Transform data using federated model
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Federated features for transformation
        
        Returns
        -------
        X_transformed : FedNdarray
            Transformed data
        """
        if not self._is_fitted:
            raise RuntimeError("Model must be fitted before transformation")
        
        if isinstance(x, VDataFrame):
            x = x.values
        
        # Each party transforms locally
        transformed_list = []
        
        for party_name, device in self.devices.items():
            if device in x.partitions:
                X_local = x.partitions[device]
                model = self.local_models[party_name]
                
                X_trans = device(lambda m, X: m.transform(X))(model, X_local)
                transformed_list.append(X_trans)
        
        # Aggregate transformed data
        if len(transformed_list) == 1:
            return transformed_list[0]
        else:
            # Use SPU for secure aggregation if available
            if self.spu:
                return self._secure_aggregate_transform(transformed_list)
            else:
                logging.warning("[FL] Using non-secure aggregation (SPU not provided)")
                return self._simple_aggregate_transform(transformed_list)
    
    def fit_transform(self, x: Union[FedNdarray, VDataFrame]):
        """
        Fit the model and transform data
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Federated features
        
        Returns
        -------
        X_transformed : FedNdarray
            Transformed data
        """
        self.fit(x)
        return self.transform(x)
    
    def inverse_transform(self, x: Union[FedNdarray, VDataFrame]):
        """
        Inverse transform data (if supported by the algorithm)
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Transformed features
        
        Returns
        -------
        X_original : FedNdarray
            Original space data
        """
        if not self._is_fitted:
            raise RuntimeError("Model must be fitted before inverse transformation")
        
        if isinstance(x, VDataFrame):
            x = x.values
        
        # Each party inverse transforms locally
        inverse_list = []
        
        for party_name, device in self.devices.items():
            if device in x.partitions:
                X_local = x.partitions[device]
                model = self.local_models[party_name]
                
                # Check if inverse_transform is available
                def _local_inverse(m, X):
                    if hasattr(m, 'inverse_transform'):
                        return m.inverse_transform(X)
                    else:
                        raise AttributeError(f"{type(m).__name__} does not support inverse_transform")
                
                X_inv = device(_local_inverse)(model, X_local)
                inverse_list.append(X_inv)
        
        # Aggregate
        if len(inverse_list) == 1:
            return inverse_list[0]
        else:
            if self.spu:
                return self._secure_aggregate_transform(inverse_list)
            else:
                return self._simple_aggregate_transform(inverse_list)
    
    def _secure_aggregate_transform(self, transform_list):
        """
        Securely aggregate transformed data using SPU encryption
        """
        logging.info("[FL] Secure transformation aggregation via SPU")
        aggregator = SecureAggregator(device=self.spu)
        if self.aggregation_method == 'mean':
            return aggregator.average(transform_list)
        elif self.aggregation_method == 'weighted_mean':
            # TODO: Implement weighted aggregation
            return aggregator.average(transform_list)
        else:
            raise ValueError(f"Unsupported aggregation method: {self.aggregation_method}")
    
    def _simple_aggregate_transform(self, transform_list):
        """
        Simple (non-secure) transformation aggregation - for development/testing only
        
        WARNING: This does not preserve privacy. Use only for testing.
        """
        if len(transform_list) == 1:
            return transform_list[0]
        
        # Simple average
        return np.mean(transform_list, axis=0)
    
    @property
    def components_(self):
        """
        Get components from local models (for PCA, NMF, etc.)
        
        Note: In federated setting, this returns aggregated components
        """
        if not self._is_fitted:
            raise RuntimeError("Model must be fitted first")
        
        # Collect components from all parties
        components_list = []
        for party_name, device in self.devices.items():
            model = self.local_models[party_name]
            components = device(lambda m: getattr(m, 'components_', None))(model)
            if components is not None:
                components_list.append(components)
        
        if not components_list:
            return None
        
        # Aggregate components
        if self.spu:
            aggregator = SecureAggregator(device=self.spu)
            return aggregator.average(components_list)
        else:
            return np.mean(components_list, axis=0)
    
    @property
    def explained_variance_(self):
        """
        Get explained variance (for PCA, etc.)
        """
        if not self._is_fitted:
            raise RuntimeError("Model must be fitted first")
        
        # Collect from all parties
        variance_list = []
        for party_name, device in self.devices.items():
            model = self.local_models[party_name]
            variance = device(lambda m: getattr(m, 'explained_variance_', None))(model)
            if variance is not None:
                variance_list.append(variance)
        
        if not variance_list:
            return None
        
        # Aggregate
        if self.spu:
            aggregator = SecureAggregator(device=self.spu)
            return aggregator.average(variance_list)
        else:
            return np.mean(variance_list, axis=0)
    
    @property
    def explained_variance_ratio_(self):
        """
        Get explained variance ratio (for PCA, etc.)
        """
        if not self._is_fitted:
            raise RuntimeError("Model must be fitted first")
        
        # Collect from all parties
        ratio_list = []
        for party_name, device in self.devices.items():
            model = self.local_models[party_name]
            ratio = device(lambda m: getattr(m, 'explained_variance_ratio_', None))(model)
            if ratio is not None:
                ratio_list.append(ratio)
        
        if not ratio_list:
            return None
        
        # Aggregate
        if self.spu:
            aggregator = SecureAggregator(device=self.spu)
            return aggregator.average(ratio_list)
        else:
            return np.mean(ratio_list, axis=0)
