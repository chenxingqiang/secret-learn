# Author: Chen Xingqiang
# SPDX-License-Identifier: BSD-3-Clause

"""
Federated Learning adapter for PassiveAggressiveClassifier

PassiveAggressiveClassifier is an ITERATIVE SUPERVISED algorithm.
Data aggregated to SPU with full MPC protection.
SPU-based secure aggregation after each epoch.

Mode: Federated Learning (FL)
Generated by: StandaloneAlgorithmMigrator
"""

import logging
from typing import Dict, Union, Optional

import numpy as np

try:
    from xlearn.linear_model import PassiveAggressiveClassifier
    USING_XLEARN = True
except ImportError:
    from sklearn.linear_model import PassiveAggressiveClassifier
    USING_XLEARN = False

try:
    from secretflow.data.ndarray.ndarray import FedNdarray
    from secretflow.data.vertical.dataframe import VDataFrame
    from secretflow.device import PYU, SPU
    from secretflow.device.device.pyu import PYUObject
    from secretflow.security.aggregation import SecureAggregator
    SECRETFLOW_AVAILABLE = True
except ImportError:
    SECRETFLOW_AVAILABLE = False


class FLPassiveAggressiveClassifier:
    """
    Federated Learning PassiveAggressiveClassifier
    
    PassiveAggressiveClassifier is an iterative supervised algorithm that supports
    incremental learning via partial_fit.
    
    In SS mode:
    - Each party performs local partial_fit in each epoch
    - Model parameters are securely aggregated via SPU after each epoch
    - Supports online/incremental learning
    
    Parameters
    ----------
    spu : SPU
        Dictionary mapping party names to PYU devices
    spu : SPU, optional
        Homomorphic encryption unit for secure aggregation
    **kwargs
        Parameters passed to PassiveAggressiveClassifier
    
    Examples
    --------
    >>> model = FLPassiveAggressiveClassifier(
    >>>     devices={'alice': alice, 'bob': bob},
    >>>     spu=spu
    >>> )
    >>> # Iterative training with multiple epochs
    >>> model.fit(fed_X, fed_y, epochs=10)
    >>> predictions = model.predict(fed_X_test)
    """
    
    def __init__(
        self,
        spu : SPU,
        spu: Optional[SPU] = None,
        **kwargs
    ):
        if not SECRETFLOW_AVAILABLE:
            raise RuntimeError("SecretFlow not installed. Install: pip install secretflow")
        
        self.devices = devices
        self.spu = spu
        self.kwargs = kwargs
        
        self.local_models = {}
        for party_name, device in devices.items():
            self.local_models[party_name] = device(self._create_local_model)(**kwargs)
        
        self._is_fitted = False
        
        if USING_XLEARN:
            logging.info("[FL] FLPassiveAggressiveClassifier initialized with JAX acceleration")
        else:
            logging.info("[FL] FLPassiveAggressiveClassifier initialized with sklearn")
    
    @staticmethod
    def _create_local_model(**kwargs):
        return PassiveAggressiveClassifier(**kwargs)
    
    def fit(
        self,
        x: Union[FedNdarray, VDataFrame],
        y: Union[FedNdarray, VDataFrame],
        epochs: int = 10
    ):
        """
        Iterative training with partial_fit
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Federated features
        y : FedNdarray or VDataFrame
            Federated labels
        epochs : int
            Number of training epochs (default: 10)
        """
        if isinstance(x, VDataFrame):
            x = x.values
        if isinstance(y, VDataFrame):
            y = y.values
        
        logging.info(f"[FL] Starting federated PassiveAggressiveClassifier training (iterative, {epochs} epochs)")
        
        for epoch in range(epochs):
            for party_name, device in self.devices.items():
                if device in x.partitions:
                    X_local = x.partitions[device]
                    y_local = y.partitions.get(device, y)
                    model = self.local_models[party_name]
                    
                    def _local_partial_fit(model, X, y):
                        # Get classes for first call
                        classes = None
                        if not hasattr(model, 'classes_'):
                            classes = np.unique(y)
                            model.partial_fit(X, y, classes=classes)
                        else:
                            model.partial_fit(X, y)
                        
                        # Return parameters
                        params = {}
                        if hasattr(model, 'coef_'):
                            params['coef_'] = model.coef_
                        if hasattr(model, 'intercept_'):
                            params['intercept_'] = model.intercept_
                        return params
                    
                    result = device(_local_partial_fit)(model, X_local, y_local)
            
            # Aggregate parameters after each epoch
            if self.spu:
                self._secure_aggregate_parameters()
            
            logging.info(f"[FL] Epoch {epoch+1}/{epochs} completed")
        
        self._is_fitted = True
        logging.info("[FL] Federated PassiveAggressiveClassifier training completed")
        return self
    
    def partial_fit(
        self,
        x: Union[FedNdarray, VDataFrame],
        y: Union[FedNdarray, VDataFrame],
        classes=None
    ):
        """
        Incremental fit on a batch of samples
        
        Parameters
        ----------
        x : FedNdarray or VDataFrame
            Batch of features
        y : FedNdarray or VDataFrame
            Batch of labels
        classes : array-like, optional
            Classes for classification (required on first call)
        """
        if isinstance(x, VDataFrame):
            x = x.values
        if isinstance(y, VDataFrame):
            y = y.values
        
        for party_name, device in self.devices.items():
            if device in x.partitions:
                X_local = x.partitions[device]
                y_local = y.partitions.get(device, y)
                model = self.local_models[party_name]
                
                def _local_partial_fit(model, X, y, classes):
                    if classes is not None:
                        model.partial_fit(X, y, classes=classes)
                    else:
                        model.partial_fit(X, y)
                    return True
                
                device(_local_partial_fit)(model, X_local, y_local, classes)
        
        # Aggregate parameters
        if self.spu:
            self._secure_aggregate_parameters()
        
        self._is_fitted = True
        return self
    
    def predict(self, x: Union[FedNdarray, VDataFrame]):
        """Predict using federated model"""
        if not self._is_fitted:
            raise RuntimeError("Model must be fitted before prediction")
        
        if isinstance(x, VDataFrame):
            x = x.values
        
        predictions_list = []
        for party_name, device in self.devices.items():
            if device in x.partitions:
                X_local = x.partitions[device]
                model = self.local_models[party_name]
                pred = device(lambda m, X: m.predict(X))(model, X_local)
                predictions_list.append(pred)
        
        if len(predictions_list) == 1:
            return predictions_list[0]
        else:
            if self.spu:
                aggregator = SecureAggregator(device=self.spu)
                return aggregator.average(predictions_list)
            else:
                return np.mean(predictions_list, axis=0)
    
    def _secure_aggregate_parameters(self):
        """Securely aggregate model parameters using SPU"""
        logging.debug("[FL] Secure parameter aggregation via SPU")
        aggregator = SecureAggregator(device=self.spu)
        # TODO: Implement actual parameter aggregation
        pass
